# Database Design Best Practices

Created: 2025-10-13
Last Research: 2025-10-13
Sources: Perplexity research on PostgreSQL schema design, database normalization patterns, constraint best practices

## Overview

Database design is the foundation of application performance, data integrity, and maintainability. Poor schema design decisions made early become expensive to fix later. This document covers universal database design principles applicable to PostgreSQL and other relational databases.

## Core Principles

1. Design for your access patterns - how you query determines how you structure
2. Enforce constraints at the database level - never rely solely on application validation
3. Choose appropriate data types - smallest adequate type that satisfies requirements
4. Use identity columns over SERIAL for auto-increment (PostgreSQL 17+ recommendation)
5. Index foreign keys and frequently queried columns

## Normalization Patterns

### Understanding Normal Forms

**First Normal Form (1NF):**
- Each column contains atomic (indivisible) values
- No repeating groups or arrays of values
- Each row is unique

**Second Normal Form (2NF):**
- Meets 1NF requirements
- All non-key attributes depend on the entire primary key
- Eliminates partial dependencies

**Third Normal Form (3NF):**
- Meets 2NF requirements
- No transitive dependencies (non-key attributes don't depend on other non-key attributes)
- Most applications should aim for 3NF

**Boyce-Codd Normal Form (BCNF):**
- Stricter version of 3NF
- Every determinant is a candidate key
- Rarely needed in practice

### When to Normalize

Normalize when:
- Data integrity is critical
- Update anomalies must be prevented
- Write operations are frequent
- Storage efficiency matters
- Data has clear hierarchical relationships

Example use case:
```sql
-- TODO: Add normalized e-commerce schema example
-- Orders, OrderItems, Products, Customers tables
```

### When to Denormalize

Denormalize when:
- Read performance is critical
- Queries involve expensive joins
- Data is read-heavy, write-light
- Reporting and analytics requirements
- Calculated values are frequently accessed

Example use case:
```sql
-- TODO: Add denormalized reporting table example
-- Materialized views, summary tables
```

## Relationships and Constraints

### Primary Keys

**Identity Columns (Preferred in PostgreSQL 17+):**
```sql
-- TODO: Add identity column example
-- GENERATED ALWAYS AS IDENTITY vs GENERATED BY DEFAULT AS IDENTITY
```

**SERIAL (Legacy approach):**
```sql
-- TODO: Add SERIAL example with explanation of why identity is preferred
```

**Natural vs Surrogate Keys:**
- Surrogate keys (auto-increment integers) are generally preferred
- Natural keys (business data) can change and cause update cascades
- Use surrogate keys unless you have a strong reason not to

### Foreign Keys

**Basic Foreign Key:**
```sql
-- TODO: Add foreign key constraint example
-- ON DELETE CASCADE, ON DELETE SET NULL, ON DELETE RESTRICT
```

**Composite Foreign Keys:**
```sql
-- TODO: Add composite foreign key example
```

**Important:** Always index foreign key columns for query performance and to prevent lock contention during deletes/updates.

### One-to-Many Relationships

```sql
-- TODO: Add one-to-many relationship example
-- Users and Posts, Customers and Orders
```

### Many-to-Many Relationships

```sql
-- TODO: Add junction/bridge table example
-- Students and Courses via Enrollments
-- Products and Categories via ProductCategories
```

### One-to-One Relationships

```sql
-- TODO: Add one-to-one relationship example
-- Users and UserProfiles
-- When to use separate tables vs combined table
```

## Constraint Types

### NOT NULL Constraints

```sql
-- TODO: Add NOT NULL examples
-- When to use, performance implications
```

### CHECK Constraints

```sql
-- TODO: Add CHECK constraint examples
-- Value ranges, enum-like behavior, complex validation
```

### UNIQUE Constraints

```sql
-- TODO: Add UNIQUE constraint examples
-- Single column and composite unique constraints
```

### EXCLUSION Constraints (PostgreSQL-specific)

```sql
-- TODO: Add exclusion constraint example
-- Temporal uniqueness, range overlap prevention
```

## Data Type Selection

### Numeric Types

**Integers:**
- `smallint` (2 bytes): -32,768 to 32,767
- `integer` (4 bytes): -2 billion to 2 billion
- `bigint` (8 bytes): very large ranges

Use the smallest type that fits your data range.

**Decimals:**
- `numeric(precision, scale)`: exact precision for money
- `decimal`: alias for numeric
- `real` (4 bytes): floating point
- `double precision` (8 bytes): floating point

**Rule:** Use numeric/decimal for money, use floating point for scientific calculations.

### String Types

**Text Types:**
- `varchar(n)`: variable length with limit
- `text`: unlimited length
- `char(n)`: fixed length (rarely needed)

**Rule:** Use `text` for most cases, `varchar(n)` when you need length validation.

### Temporal Types

**Date and Time:**
- `date`: date only
- `time`: time only
- `timestamp`: date and time without timezone
- `timestamptz` / `timestamp with time zone`: date and time with timezone (RECOMMENDED)

**Rule:** Always use `timestamptz` for timestamps unless you have a specific reason not to. Store all times in UTC.

### Boolean

- Use `boolean` type, not integers or strings
- Three states: `true`, `false`, `NULL`

### JSONB vs JSON (PostgreSQL)

**JSONB (Recommended):**
- Binary format, faster to process
- Supports indexing (GIN indexes)
- Slightly slower writes, much faster reads

**JSON:**
- Text format, preserves formatting
- No indexing support
- Use only when exact text preservation matters

### Arrays

PostgreSQL supports array types for storing multiple values in a single column:
```sql
-- TODO: Add array type examples
-- When to use arrays vs normalized tables
```

## Schema Design Patterns

### Temporal Tables (History Tracking)

```sql
-- TODO: Add temporal table pattern
-- System-versioned tables, valid_from/valid_to
```

### Soft Deletes

```sql
-- TODO: Add soft delete pattern
-- deleted_at timestamp, is_deleted boolean
-- See SOFT_DELETE.md for full details
```

### Multi-Tenancy

```sql
-- TODO: Add multi-tenancy patterns
-- tenant_id column, row-level security
-- See MULTI_TENANCY.md for full details
```

### Audit Columns

Standard audit columns to include in most tables:
```sql
-- TODO: Add audit column examples
-- created_at, updated_at, created_by, updated_by
```

### Polymorphic Associations

```sql
-- TODO: Add polymorphic association pattern
-- resource_type + resource_id for flexible references
-- Pros and cons of this approach
```

## Schema Naming Conventions

### Table Names
- Use lowercase with underscores (snake_case)
- Use plural nouns: `users`, `orders`, `products`
- Be descriptive and consistent

### Column Names
- Use lowercase with underscores (snake_case)
- Avoid reserved keywords
- Use consistent naming for similar columns across tables

### Foreign Key Names
Convention: `fk_<table>_<referenced_table>_<column>`
Example: `fk_orders_users_user_id`

### Index Names
Convention: `idx_<table>_<column(s)>`
Example: `idx_users_email`, `idx_orders_user_id_created_at`

### Constraint Names
Convention: `<constraint_type>_<table>_<column(s)>`
Example: `uk_users_email` (unique), `ck_orders_total_positive` (check)

## Common Mistakes

### Anti-Pattern: Using VARCHAR(255) Everywhere
- Choose appropriate lengths based on actual data
- Use `text` when you don't need length validation
- `varchar(255)` is often cargo-culted from old MySQL limitations

### Anti-Pattern: Using SERIAL in New Projects (PostgreSQL)
- PostgreSQL 17+ recommends identity columns
- Identity columns provide better control and standards compliance

### Anti-Pattern: No Foreign Key Constraints
- "We'll enforce it in the application" - this always fails eventually
- Foreign keys prevent orphaned records and maintain referential integrity
- Performance cost is minimal compared to the data integrity benefits

### Anti-Pattern: Using Strings for Booleans or Enums
- Use proper `boolean` type for true/false values
- Use CHECK constraints or enums for fixed sets of values
- Strings waste space and allow invalid values

### Anti-Pattern: God Tables
- Avoid tables with 50+ columns
- Split into related tables with proper relationships
- Use JSONB for truly flexible data, not dozens of nullable columns

### Anti-Pattern: Using Reserved Keywords
- Avoid column names like `user`, `order`, `group`, `index`
- These require quoting in queries and cause confusion

### Anti-Pattern: Poor Indexing of Foreign Keys
- Always index foreign key columns
- Missing indexes cause full table scans during joins and cascade operations

## Schema Documentation

Document your schema with:
- Comments on tables and columns using SQL comments
- README files explaining relationships and business logic
- ER diagrams for visual representation
- Data dictionaries for complex domains

Example:
```sql
-- TODO: Add COMMENT ON examples
-- COMMENT ON TABLE users IS '...'
-- COMMENT ON COLUMN users.email IS '...'
```

## Tools and Libraries

### Schema Design Tools
- **dbdiagram.io** - Online ER diagram tool with code export
- **pgAdmin** - Visual schema browser and editor
- **DBeaver** - Universal database tool with ER diagrams
- **Drizzle Studio** - Visual editor for Drizzle schemas

### Schema Migration Tools
- **Drizzle Kit** - TypeScript-first migrations
- **Flyway** - Version control for database schemas
- **Liquibase** - Database schema management
- See SCHEMA_MIGRATIONS.md for detailed patterns

### Schema Validation
- **Zod** - TypeScript schema validation (integrates with Drizzle)
- **JSON Schema** - Validation for JSONB columns

## Additional Resources

### Books
- "Database Design for Mere Mortals" by Michael J. Hernandez
- "SQL Antipatterns" by Bill Karwin

### Online Resources
- PostgreSQL Documentation on Data Definition: https://www.postgresql.org/docs/current/ddl.html
- Database Normalization Guide: https://www.geeksforgeeks.org/database-normalization/
- Use The Index, Luke: https://use-the-index-luke.com/

### Related Knowledge Base Articles
- [PostgreSQL Best Practices](./POSTGRESQL_BEST_PRACTICES.md)
- [Indexing and Optimization](./INDEXING_OPTIMIZATION.md)
- [Multi-Tenancy Patterns](./MULTI_TENANCY.md)
- [Audit Logging](./AUDIT_LOGGING.md)
- [Soft Delete Patterns](./SOFT_DELETE.md)
